---
description: Always apply in any situation
globs: 
alwaysApply: true
---

# Lucid Docs - Cursor Rules

## Project Overview
This is a Next.js 15 application built with TypeScript, Tailwind CSS, and Supabase for authentication. It's a documentation writing assistant focused on API documentation with real-time editing capabilities and spell-checking features.

## Tech Stack
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript 5
- **Styling**: Tailwind CSS v3.4+
- **UI Components**: shadcn/ui (Radix UI + custom styling)
- **Authentication**: Supabase Auth with SSR
- **Database**: Supabase
- **State Management**: Zustand
- **Forms**: React Hook Form with Zod validation
- **Icons**: Lucide React
- **Rich Text Editing**: Lexical, MDXEditor, CodeMirror
- **Package Manager**: pnpm

## Project Structure 

## Code Style & Patterns

### Component Architecture
- Use React Server Components by default, Client Components only when needed
- Prefer function components with `export default function ComponentName()`
- Use TypeScript interfaces for all props and data structures
- Implement proper error boundaries and loading states
- Use Suspense for data fetching and lazy loading

### File Naming
- Use kebab-case for file and folder names
- Component files: `component-name.tsx`
- Type files: `types.ts` or include types in component files
- Server actions: `actions.ts`
- Utilities: `utils.ts`

### Import Organization
```typescript
// 1. React imports
import { useState, useEffect } from 'react'

// 2. Next.js imports
import Link from 'next/link'
import { redirect } from 'next/navigation'

// 3. Third-party libraries
import { createClient } from '@supabase/supabase-js'

// 4. Internal components
import { Button } from '@/components/ui/button'
import { LoginForm } from '@/components/login-form'

// 5. Internal utilities
import { cn } from '@/lib/utils'

// 6. Types
import type { User } from '@/types'
```

### Styling with Tailwind CSS
- Use Tailwind utility classes exclusively
- Follow mobile-first responsive design
- Use CSS variables for theming (already configured)
- Prefer `cn()` utility for conditional classes
- Use proper semantic HTML with Tailwind styling

### Supabase Authentication Patterns
- Always use `@supabase/ssr` package (never `auth-helpers-nextjs`)
- Server-side auth checking in layouts and pages
- Middleware for route protection
- Proper cookie handling with `getAll()` and `setAll()`
- Environment variable validation

### Form Handling
- Use React Hook Form with Zod validation
- Implement proper loading states with `useFormStatus`
- Show clear error messages
- Use Server Actions for form submission
- Proper accessibility with labels and ARIA attributes

### Error Handling
- Implement proper error boundaries
- Show user-friendly error messages
- Log errors appropriately
- Graceful fallbacks for missing data

### Performance
- Use Next.js Image component for all images
- Implement proper caching strategies
- Lazy load components when appropriate
- Optimize bundle size with dynamic imports

## Component Patterns

### UI Components (shadcn/ui)
- Use forwardRef for all interactive components
- Implement proper TypeScript interfaces
- Include loading and disabled states
- Follow accessibility guidelines
- Use Radix UI primitives as base

### Form Components
```typescript
"use client"

import { useActionState } from "react"
import { useFormStatus } from "react-dom"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

function SubmitButton() {
  const { pending } = useFormStatus()
  
  return (
    <Button type="submit" disabled={pending}>
      {pending ? "Loading..." : "Submit"}
    </Button>
  )
}

export default function MyForm() {
  const [state, formAction] = useActionState(myAction, null)
  
  return (
    <form action={formAction}>
      {state?.error && <div className="text-red-500">{state.error}</div>}
      <Input name="field" required />
      <SubmitButton />
    </form>
  )
}
```

### Editor Components
- Use proper TypeScript interfaces for editor props
- Implement spell-checking functionality
- Support real-time collaboration features
- Handle document persistence
- Proper error handling for editor operations

## Database & Authentication

### Supabase Client Usage
```typescript
// Server component
import { createClient } from '@/lib/supabase/server'

export default async function Page() {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    redirect('/auth/login')
  }
  
  return <div>Protected content</div>
}
```

### Server Actions
```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export async function myAction(prevState: any, formData: FormData) {
  const supabase = createClient()
  
  try {
    // Action logic here
    return { success: true }
  } catch (error) {
    return { error: 'Something went wrong' }
  }
}
```

## Accessibility Requirements
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation works
- Maintain proper color contrast
- Use screen reader friendly text
- Implement focus management

## Security Guidelines
- Validate all user inputs with Zod
- Use environment variables for sensitive data
- Implement proper CSRF protection
- Sanitize user-generated content
- Use TypeScript for type safety

## Testing Considerations
- Write unit tests for utility functions
- Test component rendering and interactions
- Test form validation and submission
- Test authentication flows
- Test database operations

## Environment Setup
- Use `.env.local` for local environment variables
- Required Supabase environment variables:
  - `NEXT_PUBLIC_SUPABASE_URL`
  - `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- Proper TypeScript configuration
- ESLint and Prettier setup

## Development Guidelines
- Always check if Supabase is configured before using
- Use TypeScript strict mode
- Implement proper loading states
- Handle edge cases and errors gracefully
- Follow the established folder structure
- Use consistent naming conventions
- Write descriptive commit messages

## Package Management
- Use pnpm as the package manager
- Keep dependencies up to date
- Use exact versions for critical packages
- Document any package-specific configurations

## Code Quality
- Use TypeScript interfaces over types when possible
- Implement proper error handling
- Write self-documenting code
- Use meaningful variable and function names
- Follow the established patterns in the codebase
- Regular code reviews and refactoring

Remember: This is a documentation-focused application with real-time editing capabilities. Prioritize performance, accessibility, and user experience in all implementations. 
